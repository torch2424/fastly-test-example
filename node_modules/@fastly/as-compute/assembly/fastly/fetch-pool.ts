// Copyright 2020 Fastly, Inc.

import { Request, Response, Body, Headers, Status } from "@fastly/as-fetch";

import {
  FastlyUpstreamRequest,
  FastlyUpstreamRequestInit,
} from "./fastly-upstream/fastly-upstream-request";

import { FastlyPendingUpstreamRequest } from "./fastly-upstream/fastly-pending-upstream-request";

import { FastlyUpstreamResponse } from "./fastly-upstream/fastly-upstream-response";

import {
  PendingRequestHandle,
  ResponseHandle,
  BodyHandle,
  fastly_http_req_pending_req_select,
} from "./abi/abi";

import { FASTLY_STATUS } from "./abi/fastly-shared";

/**
 * A fulfilled pending request. This class contains the request that was sent upstream,
 * the backend that represents where the upstream was sent,
 * and the response that was returned from the origin.
 */
export class FufilledRequest {
  /**
   * The `as-fetch` request that was fufilled.
   */
  request: Request;
  /**
   * Backend that the request was sent to.
   */
  backend: string;
  /**
   * `as-fetch` {@linkcode Response} that was completed and sent back after sending the request.
   */
  response: Response;

  /**
   * @hidden
   */
  constructor(request: Request, backend: string, response: Response) {
    this.request = request;
    this.backend = backend;
    this.response = response;
  }
}

// Make multiple requests at the same time, and return a Response Pool object
// Pooling is probably the right word for this, as it seems to be used for other
// similar promise-like APIs that want to handle async/concurrent things as they come in
/**
 * FetchPool allows "pooling" {@linkcode PendingRequest}s and handling the
 * fulfillment of one or all of the requests.
 *
 * FetchPool is useful for dispatching multiple requests at the same time
 * and handling the requests as they're fulfilled,
 * rather than waiting for requests to be fulfilled one by one.
 */
export class FetchPool {
  /**
   * @hidden
   */
  private _pendingUpstreamRequests: Array<FastlyPendingUpstreamRequest>;

  constructor() {
    this._pendingUpstreamRequests = new Array<FastlyPendingUpstreamRequest>();
  }

  /**
   * Add a {@linkcode PendingRequest} to the fetch pool.
   *
   * @param pendingRequest A {@linkcode PendingRequest} returned from a {@linkcode Fetchly.fetch()} call.
   */
  push(pendingRequest: FastlyPendingUpstreamRequest): void {
    this._pendingUpstreamRequests.push(pendingRequest);
  }

  /**
   * The number of {@linkcode PendingRequest}s added to the pool.
   *
   * @returns number of requests.
   */
  length(): i32 {
    return this._pendingUpstreamRequests.length;
  }

  /**
   * Get any of the {@linkcode PendingRequest}s in the pool that have been fufilled.
   *
   * @returns Fufilled request if there are pending requests in the pool, null if not.
   */
  any(): FufilledRequest | null {
    if (this._pendingUpstreamRequests.length == 0) {
      return null;
    }

    // Throw all of our pending request handles into a buffer
    let pendingRequestHandles = new Uint32Array(
      this._pendingUpstreamRequests.length
    );
    for (let i = 0; i < this._pendingUpstreamRequests.length; i++) {
      pendingRequestHandles[i] = this._pendingUpstreamRequests[
        i
      ]._pendingRequestHandle;
    }

    // Allocate our destionation pointers
    let doneIndexOutPointer = __alloc(4);
    let respHandleOutPointer = __alloc(4);
    let respBodyHandleOutPointer = __alloc(4);

    let selectStatus = fastly_http_req_pending_req_select(
      pendingRequestHandles.buffer,
      pendingRequestHandles.length,
      doneIndexOutPointer,
      respHandleOutPointer,
      respBodyHandleOutPointer
    );
    if (FASTLY_STATUS.isError(selectStatus)) {
      throw new Error("FetchPool.any() select hostcall failed");
    }

    // Get all of our values
    let doneIndex = load<i32>(doneIndexOutPointer);
    let responseHandle = load<u32>(respHandleOutPointer);
    let responseBodyHandle = load<u32>(respBodyHandleOutPointer);
    __free(doneIndexOutPointer);
    __free(respHandleOutPointer);
    __free(respBodyHandleOutPointer);

    // Get and splice out our pending request
    let request = this._pendingUpstreamRequests[doneIndex];
    this._pendingUpstreamRequests.splice(doneIndex, 1);

    // Create our response
    let response = new FastlyUpstreamResponse(
      request.url,
      responseHandle,
      responseBodyHandle
    );

    // Create our fufilled Request
    let fufilledRequest = new FufilledRequest(
      request,
      request._backend,
      response
    );

    return fufilledRequest;
  }

  /**
   * Waits for all the of {@linkcode PendingRequest}s in the pool to be fulfilled and returns them.
   *
   * @returns an Array of the Fufilled Requests.
   */
  all(): Array<FufilledRequest> {
    let fufilledRequests = new Array<FufilledRequest>();
    while (this._pendingUpstreamRequests.length > 0) {
      let fufilledRequest = this.any();
      if (fufilledRequest !== null) {
        fufilledRequests.push(fufilledRequest);
      }
    }

    return fufilledRequests;
  }
}
