// Copyright 2020 Fastly, Inc.

// Fastly is a namespace for allowing:
//   * as-fetch to interact with Fastly Compute@Edge
//   * Interact with Fastly Specific APIs

import { Request, Response, Body, Headers } from "@fastly/as-fetch";

import {
  RequestHandle,
  ResponseHandle,
  BodyHandle,
  fastly_http_body_append,
} from "./abi/abi";

import { FASTLY_STATUS, BODY_WRITE_END } from "./abi/fastly-shared";

import { FastlyUpstreamRequest } from "./fastly-upstream/fastly-upstream-request";
import { FastlyPendingUpstreamRequest } from "./fastly-upstream/fastly-pending-upstream-request";
import { FastlyUpstreamResponse } from "./fastly-upstream/fastly-upstream-response";
import { FastlyDownstreamRequest } from "./fastly-downstream/fastly-downstream-request";
import { FastlyDownstreamResponse } from "./fastly-downstream/fastly-downstream-response";
import {
  getDownstreamIpAddressBytes,
  getDownstreamIpAddressString,
} from "./fastly-downstream/fastly-downstream-util";

import { CacheOverride } from "./cache-override";
import { WriteableBodyStream } from "./stream/writeable-body-stream";
import { LogEndpoint } from "./log-endpoint";

export { FastlyPendingUpstreamRequest } from "./fastly-upstream/fastly-pending-upstream-request";
export { FastlyUpstreamResponse } from "./fastly-upstream/fastly-upstream-response";

export { CacheOverride } from "./cache-override";
export { Dictionary } from "./dictionary";
export {
  ReadableBodyStream,
  ReadableBodyStreamReader,
  ReadResponse,
} from "./stream/readable-body-stream";
export {
  WriteableBodyStream,
  WriteableBodyStreamWriter,
} from "./stream/writeable-body-stream";
export { FetchPool, FufilledRequest } from "./fetch-pool";
export { LogEndpoint } from "./log-endpoint";
export {
  getGeolocationForIpAddress,
  Geolocation,
  GeolocationPrimitive,
} from "./geoip";

// Using the word client as it is some similar
// contextually to C@E and service worker FetchEvent

/**
 * Function to get the downstream request from the client.
 * This can only be called once per execution.
 *
 * @returns an `as-fetch` {@linkcode Request} Object representing the client request.
 */
export function getClientRequest(): Request {
  let fastlyDownstreamRequest = new FastlyDownstreamRequest();
  return fastlyDownstreamRequest;
}

/**
 * Function to get the IP Address of the client who sent the downstream request.
 *
 * This function returns an array buffer, which will have a `byteLength` of
 * 4 if IPv4, or 16 if IPv6.
 *
 * @returns ArrayBuffer - A byte buffer of the IPv4 or IPv6 address.
 */
export function getClientIpAddressBytes(): ArrayBuffer {
  return getDownstreamIpAddressBytes();
}

/**
 * Function to get the IP Address of the client who sent the downstream request.
 *
 * @returns string - A string representation of the IPv4 or IPv6 address.
 */
export function getClientIpAddressString(): string {
  return getDownstreamIpAddressString();
}

/**
 * The configuration object to apply to the Fetch.
 *
 * Similar to the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters),
 * the parameters here will be applied to the `as-fetch` {@linkcode Request} being sent in the `fetch` call.
 */
export class FetchInit {
  /**
   * The backend the request should be sent to.
   */
  backend: string;
  /**
   * An optional CacheOverride to applied to the request.
   */
  cacheOverride: CacheOverride | null;
}

/**
 * Send a an external request to fetch a resource.
 * Useful for making upstream requests to a backend.
 *
 * @param request the as-fetch Request object to fetch.
 * @param fetchInit the config object to apply to the fetch request.
 * @returns FastlyPendingUpstreamRequest for the fetched resource.
 */
export function fetch(
  request: Request,
  fetchInit: FetchInit
): FastlyPendingUpstreamRequest {
  // Convert the fetch Request, into our Fastly Request
  let fastlyUpstreamRequest = new FastlyUpstreamRequest(request.url, {
    method: request.method,
    headers: request.headers,
    body: request.arrayBuffer(),
    cacheOverride: fetchInit.cacheOverride,
  });
  let fastlyPendingUpstreamRequest = fastlyUpstreamRequest.send(
    fetchInit.backend
  );
  return fastlyPendingUpstreamRequest;
}

/**
 * The configuration object to apply to the downstream client response.
 *
 * This config can be sent with the {@linkcode Fetchly.respondWith} calls, to do
 * additional Fastly C@E functionality before responding back to the client.
 */
export class FastlyResponseConfig {
  /**
   * An array of FastlyUpstreamResponse that will be used to
   * append the body of each request to the downstream client response.
   * The body on the response is sent first, followed by the bodies of the responsesToAppend,
   * in the order that they are in the array.
   * This is useful for concatenating together large responses, without
   * having to load the bodies of each response into your wasm module.
   */
  responsesToAppend: Array<FastlyUpstreamResponse> | null = null;
}

function applyFastlyResponseConfig(
  fastlyDownstreamResponse: FastlyDownstreamResponse,
  fastlyResponseConfigOrNull: FastlyResponseConfig | null = null
): void {
  if (fastlyResponseConfigOrNull == null) {
    return;
  }

  let fastlyResponseConfig: FastlyResponseConfig =
    changetype<FastlyResponseConfig>(fastlyResponseConfigOrNull);

  // Try to append the bodies to the downstream response
  if (fastlyResponseConfig.responsesToAppend != null) {
    let upstreamResponses = changetype<Array<FastlyUpstreamResponse>>(
      fastlyResponseConfig.responsesToAppend
    );
    for (let i = 0; i < upstreamResponses.length; i++) {
      let upstreamResponse = upstreamResponses[i];
      let bodyAppendFastlyStatus = fastly_http_body_append(
        fastlyDownstreamResponse._getBodyHandle(),
        upstreamResponse._getBodyHandle()
      );
      if (FASTLY_STATUS.isError(bodyAppendFastlyStatus)) {
        throw new Error(
          "Could not append the upstream body to the downstream response."
        );
      }
    }
  }

  // Done!
}

/**
 * Send a response back downstream to the client.
 * This is meant for sending a completed response.
 * For streaming a response, use {@linkcode Fetchly.respondWithStreaming}
 *
 * @param response The as-fetch response object representing what to respond with
 */
export function respondWith(
  response: Response,
  fastlyResponseConfigOrNull: FastlyResponseConfig | null = null
): void {
  // Convert the fetch Response, into our Fastly Response,
  // And then send Downstream
  let body = response.arrayBuffer();
  let status = response.status;
  let headers = response.headers;

  let fastlyDownstreamResponse = new FastlyDownstreamResponse(body, {
    status: status,
    headers: headers,
    url: null,
  });
  applyFastlyResponseConfig(
    fastlyDownstreamResponse,
    fastlyResponseConfigOrNull
  );
  fastlyDownstreamResponse.send();
}

/**
 * Send a response back down to the client
 * and return a stream to continue writing to the body.
 * If you don't need to stream the response, use {@linkcode Fetchly.respondWith}
 *
 * @param response The `as-fetch` {@linkcode Response} object representing what to respond with.
 * @returns WriteableBodyStream so that you can continue writing to the body.
 */
export function respondWithStreaming(
  response: Response,
  fastlyResponseConfigOrNull: FastlyResponseConfig | null = null
): WriteableBodyStream {
  // Convert the fetch Response, into our Fastly Response,
  // And then send Downstream
  let body = response.arrayBuffer();
  let status = response.status;
  let headers = response.headers;

  let fastlyDownstreamResponse = new FastlyDownstreamResponse(body, {
    status: status,
    headers: headers,
    url: null,
  });
  applyFastlyResponseConfig(
    fastlyDownstreamResponse,
    fastlyResponseConfigOrNull
  );
  return fastlyDownstreamResponse.sendStreaming();
}

/**
 * Create a logging endpoint as a part of the Fetchly endpoint.
 *
 * @param endpointName Name of the endpoint to log to.
 * @returns LogEndpoint for the endpoint name.
 */
export function getLogEndpoint(endpointName: string): LogEndpoint {
  let logEndpoint = new LogEndpoint(endpointName);
  return logEndpoint;
}
