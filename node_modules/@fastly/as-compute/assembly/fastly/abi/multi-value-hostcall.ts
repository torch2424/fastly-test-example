// Copyright 2020 Fastly, Inc.

import { FASTLY_STATUS } from "./fastly-shared";

type FillBufFunc<T> = (
  handle: T,
  valueBuf: Uint8Array,
  cursorStart: u32,
  cursorEndPtr: usize,
  nwrittenPtr: usize,
  optionalBuf: Uint8Array | null
) => i32;

const MULTI_VALUE_HOST_CALL_BUFLEN = 4096;

// TODO: 2020-06-05: Once AS supports closures,
// pass the response handle in via the closure,
// rather than passing in through the FillBuf
export class MultiValueHostCall {
  handle: u32;
  fillBuf: FillBufFunc<u32>;
  term: u8;
  buf: Uint8Array;
  optionalBuf: Uint8Array | null;
  cursor: u32;
  isDone: bool;
  elements: Array<Uint8Array>;

  constructor(
    handle: u32,
    terminator: string,
    optionalBuf: Uint8Array | null,
    fillBuf: FillBufFunc<u32>
  ) {
    this.handle = handle;
    this.term = Uint8Array.wrap(String.UTF8.encode(terminator))[0];
    this.fillBuf = fillBuf;
    this.cursor = 0;
    this.isDone = false;
    this.buf = new Uint8Array(MULTI_VALUE_HOST_CALL_BUFLEN);
    this.optionalBuf = optionalBuf;
    this.elements = new Array<Uint8Array>();
  }

  next(): Uint8Array | null {
    let endingCursor: i32 = 0;
    let nwrittenOut: i32 = 0;

    if (this.elements.length == 0) {
      // if there are no more calls to make, and the buffer is empty, we're done
      if (this.isDone) {
        return null;
      }

      // clear the buffer
      this.buf.fill(0);

      // Get our pointers to our ending cursor and
      // nwritten out
      let endingCursorPointer = __alloc(4);
      let nwrittenPointer = __alloc(4);

      // Call our our passed hostcall function wrapper
      let fastlyStatus = this.fillBuf(
        this.handle,
        this.buf,
        this.cursor,
        endingCursorPointer,
        nwrittenPointer,
        this.optionalBuf
      );
      // Check if we had a buffer length error, if so expand the buffer
      while (fastlyStatus == FASTLY_STATUS.BUFLEN) {
        // We need to expand the buffer and do the call again
        this.buf = new Uint8Array(
          this.buf.byteLength + MULTI_VALUE_HOST_CALL_BUFLEN
        );
        fastlyStatus = this.fillBuf(
          this.handle,
          this.buf,
          this.cursor,
          endingCursorPointer,
          nwrittenPointer,
          this.optionalBuf
        );
      }

      if (FASTLY_STATUS.isError(fastlyStatus)) {
        this.isDone = true;
        throw new Error("MultiValueHostcall closure returned error");
      }

      endingCursor = load<i32>(endingCursorPointer);
      __free(endingCursorPointer);
      nwrittenOut = load<u32>(nwrittenPointer);
      __free(nwrittenPointer);

      // if we get no bytes, we're definitely done; this only comes up if there are no
      // values at all, otherwise we see the ending cursor at -1 and stop
      if (nwrittenOut == 0) {
        this.isDone = true;
        return null;
      }

      // if the cursor doesn't advance at all, that means there's a value that's too big
      // to fit in our buffer
      if (this.cursor == (endingCursor as u32)) {
        this.isDone = true;
        throw new Error("MultiValueHostcall buffer too small");
      }

      if (endingCursor < 0) {
        // no more calls necessary after this one
        this.isDone = true;
      } else {
        // otherwise adjust the cursor for the next fill
        this.cursor = endingCursor as u32;
      }

      // Iterate through the buffer and find all the term indexes
      let elementStartIndex = 0;
      for (let i = 0; i < nwrittenOut; i++) {
        if (this.buf[i] == this.term) {
          // create a new array, can't use subarray as we want a copy
          let element = new Uint8Array(i + 1 - elementStartIndex);
          for (let j = 0; j + elementStartIndex < i + 1; j++) {
            element[j] = this.buf[elementStartIndex + j];
          }
          elementStartIndex = i + 1;

          this.elements.push(element);
        }
      }

      if (this.elements.length == 0) {
        throw new Error("MultiValueHostcall separator byte not found");
      }
    }

    // Grab the first element from the terminator
    let element = this.elements.shift();
    return element;
  }
}
