// Copyright 2020 Fastly, Inc.

import { BodyHandle, fastly_http_body_read } from "../abi/abi";

import { FASTLY_STATUS, BODY_WRITE_END } from "../abi/fastly-shared";

/**
 * Response to a {@linkcode ReadableBodyStreamReader.read} on a ReadableBodyStreamReader.
 */
export class ReadResponse {
  /**
   * If the stream has been completely read as of the {@linkcode ReadableBodyStreamReader.read} call.
   */
  done: boolean;
  /**
   * The bytes read from the stream as an `ArrayBuffer`.
   */
  value: ArrayBuffer;
}

/**
 * Readable stream to an HTTP Request/Response Body. This is similar to
 * the [Streams API's ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
 */
export class ReadableBodyStream {
  /**
   * @hidden
   */
  private _bodyHandle: BodyHandle;

  /**
   * @hidden
   */
  _locked: boolean;

  /**
   * @hidden
   */
  constructor(bodyHandle: BodyHandle) {
    this._bodyHandle = bodyHandle;
  }

  /**
   * Get a reader to the specified associate stream,
   * which can be used to ready bytes from the stream.
   *
   * @returns {@linkcode ReadableBodyStreamReader} of the associated stream.
   */
  getReader(): ReadableBodyStreamReader | null {
    if (this._locked) {
      return null;
    }

    const reader = new ReadableBodyStreamReader(this, this._bodyHandle);

    this._locked = true;

    return reader;
  }

  /**
   * @returns true if the stream is currently locked to a {@linkcode ReadableBodyStreamReader} for this stream, false it not.
   */
  get locked(): boolean {
    return this._locked;
  }
}

/**
 * Reader to a readable stream to an HTTP Request/Response Body. This is similar to
 * the [Streams API's ReadableStreamDefaultReader](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader)
 */
export class ReadableBodyStreamReader {
  /**
   * @hidden
   */
  private _readableStream: ReadableBodyStream;
  /**
   * @hidden
   */
  private _bodyHandle: BodyHandle;
  /**
   * @hidden
   */
  private _isDone: boolean;
  /**
   * @hidden
   */
  private _closed: boolean;

  /**
   * @hidden
   */
  constructor(readableStream: ReadableBodyStream, bodyHandle: BodyHandle) {
    this._readableStream = readableStream;
    this._bodyHandle = bodyHandle;
    this._closed = false;
    this._isDone = false;
  }

  /**
   * Getter for if the reader is closed.
   *
   * @returns true if the reader is closed, false if not.
   */
  get closed(): boolean {
    return this._closed;
  }

  /**
   * Release the lock on the associated ReadableStream that created this reader
   * After releasing the lock, this reader instance is closed.
   */
  releaseLock(): void {
    this._readableStream._locked = false;
    this._closed = true;
  }

  /**
   * Continually read the stream of the body until is it completed.
   *
   * @returns an `ArrayBuffer` of the entire streamed Body Content
   */
  readAll(): ArrayBuffer {
    let remainingBodyByteArray = new Array<u8>();

    // Keep reading until we reach the end of the body.
    while (!this._isDone) {
      let readResponse = this.read();
      if (!readResponse.done) {
        let chunk = Uint8Array.wrap(readResponse.value);
        for (let i = 0; i < chunk.length; i++) {
          remainingBodyByteArray.push(chunk[i]);
        }
      }
    }

    // Convert our byte array into a typed array
    let remainingBodyTypedArray = new Uint8Array(remainingBodyByteArray.length);
    for (let i = 0; i < remainingBodyByteArray.length; i++) {
      remainingBodyTypedArray[i] = remainingBodyByteArray[i];
    }

    return remainingBodyTypedArray.buffer;
  }

  /**
   * Read a chunk from the Body stream.
   *
   * @returns ReadResponse where the `value` property contains the read chunk as an `ArrayBuffer`, and the `done` property which is true if we read the entire stream.
   */
  read(): ReadResponse {
    if (this._isDone || this._closed) {
      this.releaseLock();
      return {
        done: true,
        value: new ArrayBuffer(0),
      };
    }

    // Create a chunk to be filled
    let chunkSize = 1024;
    let chunkPtr = __alloc(chunkSize);

    let nwrittenOutPointer = __alloc(4);

    // This hostcall will block if there is no bytes yet
    // Even if it is streaming
    // Therefore if nwrittenout is 0, then we are done.
    let bodyReadStatus = fastly_http_body_read(
      this._bodyHandle,
      chunkPtr,
      chunkSize,
      nwrittenOutPointer
    );
    if (FASTLY_STATUS.isError(bodyReadStatus)) {
      throw new Error("Could not read the body in the ReadableStream");
    }

    let nwrittenOut = load<u32>(nwrittenOutPointer);
    __free(nwrittenOutPointer);

    if (nwrittenOut == 0) {
      this._isDone = true;
      this.releaseLock();
      return {
        done: true,
        value: new ArrayBuffer(0),
      };
    }

    // Iterate through the chunk, create our returned
    // value array buffer, as well as add to our
    // total body byte array
    let value = new Uint8Array(nwrittenOut);
    for (let i = 0; i < (nwrittenOut as i32); i++) {
      let byte = load<u8>(chunkPtr + i);
      value[i] = byte;
    }
    __free(chunkPtr);

    return {
      done: false,
      value: value.buffer,
    };
  }
}
