// Copyright 2020 Fastly, Inc.

import { Request, RequestInit, Body, Headers } from "@fastly/as-fetch";

import {
  RequestHandle,
  ResponseHandle,
  BodyHandle,
  fastly_http_req_new,
  fastly_http_req_uri_set,
  fastly_http_req_method_set,
  fastly_http_req_header_insert,
  fastly_http_req_cache_override_set,
  fastly_http_req_send_async,
} from "../abi/abi";

import { FASTLY_STATUS, BODY_WRITE_END } from "../abi/fastly-shared";

import {
  isNull,
  writeHeadersToHandle,
  createBodyHandleAndGetWriteableBodyStream,
} from "../../util";

import { FastlyPendingUpstreamRequest } from "./fastly-pending-upstream-request";

import { WriteableBodyStream } from "../stream/writeable-body-stream";

import { CacheOverride } from "../cache-override";

export class FastlyUpstreamRequestInit extends RequestInit {
  cacheOverride: CacheOverride | null;
}

export class FastlyUpstreamRequest extends Request {
  private _requestHandle: RequestHandle;
  private _cacheOverride: CacheOverride | null;

  constructor(url: string, init: FastlyUpstreamRequestInit) {
    // Create our underlying Request object
    super(url, init);

    // First get our handle

    // Allocate a u32 for our host function
    let requestHandlePointer = __alloc(4);
    let requestHandleStatus = fastly_http_req_new(requestHandlePointer);
    if (FASTLY_STATUS.isError(requestHandleStatus)) {
      throw new Error("Could not get the request handle from the host");
    }
    let requestHandle = load<RequestHandle>(requestHandlePointer);
    __free(requestHandlePointer);
    this._requestHandle = requestHandle;

    this._cacheOverride = init.cacheOverride;
  }

  _writeUrlToHandle(): void {
    let uriWrittenOutPointer = __alloc(4);

    // Get the method buffer
    let uriBuffer: ArrayBuffer = String.UTF8.encode(this.url);

    let uriWriteStatus = fastly_http_req_uri_set(
      this._requestHandle,
      uriBuffer,
      uriBuffer.byteLength
    );
    if (FASTLY_STATUS.isError(uriWriteStatus)) {
      throw new Error("Could not write the request URI to the host");
    }

    let uriWrittenOut = load<u32>(uriWrittenOutPointer);
    __free(uriWrittenOutPointer);
  }

  _writeMethodToHandle(): void {
    let methodWrittenOutPointer = __alloc(4);

    // Get the method buffer
    let methodBuffer: ArrayBuffer = String.UTF8.encode(this.method);

    let methodWriteStatus = fastly_http_req_method_set(
      this._requestHandle,
      methodBuffer,
      methodBuffer.byteLength
    );
    if (FASTLY_STATUS.isError(methodWriteStatus)) {
      throw new Error("Could not write the request method to the host");
    }

    let methodWrittenOut = load<u32>(methodWrittenOutPointer);
    __free(methodWrittenOutPointer);
  }

  _writeRequestHeadersToHandle(): void {
    // Write our headers to handle
    // Need to use since there is no implements yet
    writeHeadersToHandle(
      this.headers,
      this._requestHandle,
      (
        handle: ResponseHandle,
        headerNameBuffer: ArrayBuffer,
        headerValueBuffer: ArrayBuffer
      ) => {
        let headerWriteStatus = fastly_http_req_header_insert(
          handle,
          headerNameBuffer,
          headerNameBuffer.byteLength,
          headerValueBuffer,
          headerValueBuffer.byteLength
        );
        if (FASTLY_STATUS.isError(headerWriteStatus)) {
          throw new Error("Could not insert a response header on the host");
        }
      }
    );
  }

  send(backend: string): FastlyPendingUpstreamRequest {
    // Write everything to the handle
    this._writeUrlToHandle();
    this._writeMethodToHandle();
    this._writeRequestHeadersToHandle();

    // Write our body to the handle
    let writeableBodyStream = createBodyHandleAndGetWriteableBodyStream(
      this._buffer
    );

    // Check if we have a cache override
    if (this._cacheOverride != null) {
      let cacheOverride: CacheOverride = this._cacheOverride as CacheOverride;
      let cacheOverrideStatus = fastly_http_req_cache_override_set(
        this._requestHandle,
        cacheOverride.getTag(),
        cacheOverride.getTTL(),
        cacheOverride.getSWR()
      );
      if (FASTLY_STATUS.isError(cacheOverrideStatus)) {
        throw new Error("Could not set the cache override");
      }
    }

    let backendBuffer: ArrayBuffer = String.UTF8.encode(backend);

    // Create the pointers for our pending request
    let pendingRequestHandleOutPointer = __alloc(4);

    let reqSendStatus = fastly_http_req_send_async(
      this._requestHandle,
      writeableBodyStream._getBodyHandle(),
      backendBuffer,
      backendBuffer.byteLength,
      pendingRequestHandleOutPointer
    );
    if (FASTLY_STATUS.isError(reqSendStatus)) {
      throw new Error("Could not send the request");
    }

    let pendingRequestHandle = load<u32>(pendingRequestHandleOutPointer);
    __free(pendingRequestHandleOutPointer);

    let fastlyPendingUpstreamRequest = new FastlyPendingUpstreamRequest(
      pendingRequestHandle,
      backend,
      {
        url: this.url,
        method: this.method,
        headers: this.headers,
        body: null,
        cacheOverride: null,
      }
    );

    return fastlyPendingUpstreamRequest;
  }
}
