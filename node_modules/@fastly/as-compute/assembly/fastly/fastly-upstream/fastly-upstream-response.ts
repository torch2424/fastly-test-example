// Copyright 2020 Fastly, Inc.

import { Response, Body, Headers, Status } from "@fastly/as-fetch";

import {
  PendingRequestHandle,
  ResponseHandle,
  BodyHandle,
  fastly_http_resp_status_get,
  fastly_http_resp_header_names_get,
  fastly_http_resp_header_values_get,
} from "../abi/abi";

import { MultiValueHostCall } from "../abi/multi-value-hostcall";

import { FASTLY_STATUS } from "../abi/fastly-shared";

import { isNull } from "../../util";

import {
  ReadableBodyStream,
  ReadableBodyStreamReader,
  ReadResponse,
} from "../stream/readable-body-stream";

export class FastlyUpstreamResponse extends Response {
  private _responseHandle: ResponseHandle;
  private _responseBodyHandle: BodyHandle;

  // Checks for if we got properties or not
  private _hasStatusFromHandle: boolean;
  private _hasHeadersFromHandle: boolean;
  private _hasBodyFromHandle: boolean;

  constructor(
    url: string,
    responseHandle: ResponseHandle,
    responseBodyHandle: BodyHandle
  ) {
    super(null, {
      status: 200,
      headers: null,
      url: url,
    });

    // Set our handles
    this._responseHandle = responseHandle;
    this._responseBodyHandle = responseBodyHandle;

    // Set our "hasXFromHandle" properties
    this._hasStatusFromHandle = false;
    this._hasHeadersFromHandle = false;
    this._hasBodyFromHandle = false;
  }

  _getStatusFromHandle(): void {
    // Get the Response Status
    let respStatusPointer = __alloc(4);
    let respGetStatus = fastly_http_resp_status_get(
      this._responseHandle,
      respStatusPointer
    );
    let respStatus = load<u16>(respStatusPointer);
    __free(respStatusPointer);

    this._status = new Status(respStatus);
    this._hasStatusFromHandle = true;
  }

  _getHeadersFromHandle(): void {
    // Get the header names
    let headerNamesMultiValueHostCall = new MultiValueHostCall(
      this._responseHandle,
      "\0",
      null,
      (
        handle: ResponseHandle,
        buf: Uint8Array,
        cursorStart: u32,
        cursorEndPtr: usize,
        nwrittenPtr: usize,
        optionalBuf: Uint8Array | null
      ) => {
        return fastly_http_resp_header_names_get(
          handle,
          buf.buffer,
          buf.byteLength,
          cursorStart,
          cursorEndPtr,
          nwrittenPtr
        );
      }
    );

    let headerNames = new Array<string>();
    let hasNext = true;
    while (hasNext) {
      let headerNameBytes = headerNamesMultiValueHostCall.next();
      if (headerNameBytes == null) {
        hasNext = false;
      } else {
        let headerName = String.UTF8.decode(headerNameBytes.buffer, true);
        headerNames.push(headerName);
      }
    }

    // Get and append the values for every header name
    for (let i = 0; i < headerNames.length; i++) {
      // Get our headerName
      let headerName = headerNames[i];

      // Get the header values
      let headerValuesMultiValueHostCall = new MultiValueHostCall(
        this._responseHandle,
        "\0",
        Uint8Array.wrap(String.UTF8.encode(headerName)),
        (
          handle: ResponseHandle,
          buf: Uint8Array,
          cursorStart: u32,
          cursorEndPtr: usize,
          nwrittenPtr: usize,
          optionalBuf: Uint8Array | null
        ) => {
          if (optionalBuf == null) {
            throw new Error("MultiValueHostCall, did not get the header name");
          } else {
            return fastly_http_resp_header_values_get(
              handle,
              optionalBuf.buffer,
              optionalBuf.byteLength,
              buf.buffer,
              buf.byteLength,
              cursorStart,
              cursorEndPtr,
              nwrittenPtr
            );
          }
        }
      );

      let headerValues = new Array<string>();
      let hasNext = true;
      while (hasNext) {
        let headerValueBytes = headerValuesMultiValueHostCall.next();
        if (headerValueBytes == null) {
          hasNext = false;
        } else {
          let headerValue = String.UTF8.decode(headerValueBytes.buffer, true);
          headerValues.push(headerValue);
        }
      }

      // append each header value to our header name
      for (let j = 0; j < headerValues.length; j++) {
        let headerValue = headerValues[j];
        super.headers.append(headerName, headerValue);
      }
    }

    // Set that we now have out headers
    this._hasHeadersFromHandle = true;
  }

  _getBodyHandle(): BodyHandle {
    return this._responseBodyHandle;
  }

  _getBodyFromHandle(): void {
    // Create a readable stream of our body
    let bodyReaderOrNull = new ReadableBodyStream(
      this._responseBodyHandle
    ).getReader();
    if (bodyReaderOrNull == null) {
      throw new Error("Body stream reader was null");
    }
    let bodyReader = changetype<ReadableBodyStreamReader>(bodyReaderOrNull);
    let bodyArrayBuffer = bodyReader.readAll();

    // Create our Body
    this._buffer = bodyArrayBuffer;
    this._hasBodyFromHandle = true;
  }

  // Override all of our functions to fetch things lazily
  get status(): u16 {
    if (!this._hasStatusFromHandle) {
      this._getStatusFromHandle();
    }

    return super.status;
  }

  get ok(): boolean {
    if (!this._hasStatusFromHandle) {
      this._getStatusFromHandle();
    }
    return super.ok;
  }

  // TODO: Redirected

  get statusText(): string {
    if (!this._hasStatusFromHandle) {
      this._getStatusFromHandle();
    }
    return super.statusText;
  }

  get headers(): Headers {
    if (!this._hasHeadersFromHandle) {
      this._getHeadersFromHandle();
    }

    return super.headers;
  }

  get body(): ReadableBodyStream {
    // If we already waited for the response, we are done
    // and can't get a stream for the response
    this._consumeBody();

    let readableStream = new ReadableBodyStream(this._responseBodyHandle);
    return readableStream;
  }

  arrayBuffer(): ArrayBuffer | null {
    if (!this._hasBodyFromHandle) {
      this._getBodyFromHandle();
    }

    return super.arrayBuffer();
  }

  text(): string {
    if (!this._hasBodyFromHandle) {
      this._getBodyFromHandle();
    }

    return super.text();
  }
}
