// Copyright 2020 Fastly, Inc.

import { Request, RequestInit, Body, Headers } from "@fastly/as-fetch";

import {
  RequestHandle,
  BodyHandle,
  fastly_http_req_body_downstream_get,
  fastly_http_req_uri_get,
  fastly_http_req_method_get,
  fastly_http_req_header_names_get,
  fastly_http_req_header_values_get,
} from "../abi/abi";

import { MultiValueHostCall } from "../abi/multi-value-hostcall";

import { FASTLY_STATUS } from "../abi/fastly-shared";

import { getStringFromHandle } from "../../util";

import {
  ReadableBodyStream,
  ReadableBodyStreamReader,
} from "../stream/readable-body-stream";

export class FastlyDownstreamRequest extends Request {
  private _requestHandle: RequestHandle;
  private _requestBodyHandle: BodyHandle;

  // Checks for if we got properties or not
  private _hasMethodFromHandle: boolean;
  private _hasUrlFromHandle: boolean;
  private _hasHeadersFromHandle: boolean;
  private _hasBodyFromHandle: boolean;

  constructor() {
    // Create our underlying Request object
    super("", {
      method: null,
      headers: null,
      body: null,
    });

    // Allocate a u32 for our host function
    let requestHandlePointer = __alloc(4);
    let requestBodyHandlePointer = __alloc(4);
    let downstreamHandleStatus = fastly_http_req_body_downstream_get(
      requestHandlePointer,
      requestBodyHandlePointer
    );
    if (FASTLY_STATUS.isError(downstreamHandleStatus)) {
      throw new Error(
        "Could not get the downstream request and body handle " +
          "from the fastly_http_req::body_downstream_get hostcall"
      );
    }
    let requestHandle = load<RequestHandle>(requestHandlePointer);
    let requestBodyHandle = load<BodyHandle>(requestBodyHandlePointer);
    __free(requestHandlePointer);
    __free(requestBodyHandlePointer);

    this._requestHandle = requestHandle;
    this._requestBodyHandle = requestBodyHandle;
  }

  _getUrlFromHandle(): void {
    let url = getStringFromHandle(
      this._requestHandle,
      (handle: u32, chunk: ArrayBuffer, nwrittenPtr: usize) => {
        return fastly_http_req_uri_get(
          handle,
          chunk,
          chunk.byteLength,
          nwrittenPtr
        );
      }
    );

    // Set the method on our request
    this._url = url;

    this._hasUrlFromHandle = true;
  }

  _getMethodFromHandle(): void {
    let method = getStringFromHandle(
      this._requestHandle,
      (handle: u32, chunk: ArrayBuffer, nwrittenPtr: usize) => {
        return fastly_http_req_method_get(
          handle,
          chunk,
          chunk.byteLength,
          nwrittenPtr
        );
      }
    );

    // Set the method on our request
    this._method = method;

    this._hasMethodFromHandle = true;
  }

  // TODO torch2424 (6/24/2020): Once Closures are supported in AS,
  // Share this code with FastlyUpstreamResponse.getHeadersFromHandle
  _getHeadersFromHandle(): void {
    // Get the header names
    let headerNamesMultiValueHostCall = new MultiValueHostCall(
      this._requestHandle,
      "\0",
      null,
      (
        handle: RequestHandle,
        buf: Uint8Array,
        cursorStart: u32,
        cursorEndPtr: usize,
        nwrittenPtr: usize,
        optionalBuf: Uint8Array | null
      ) => {
        return fastly_http_req_header_names_get(
          handle,
          buf.buffer,
          buf.byteLength,
          cursorStart,
          cursorEndPtr,
          nwrittenPtr
        );
      }
    );

    let headerNames = new Array<string>();
    let hasNext = true;
    while (hasNext) {
      let headerNameBytes = headerNamesMultiValueHostCall.next();
      if (headerNameBytes == null) {
        hasNext = false;
      } else {
        let headerName = String.UTF8.decode(headerNameBytes.buffer, true);
        headerNames.push(headerName);
      }
    }

    // Get and append the values for every header name
    for (let i = 0; i < headerNames.length; i++) {
      // Get our headerName
      let headerName = headerNames[i];

      // Get the header values
      let headerValuesMultiValueHostCall = new MultiValueHostCall(
        this._requestHandle,
        "\0",
        Uint8Array.wrap(String.UTF8.encode(headerName)),
        (
          handle: RequestHandle,
          buf: Uint8Array,
          cursorStart: u32,
          cursorEndPtr: usize,
          nwrittenPtr: usize,
          optionalBuf: Uint8Array | null
        ) => {
          if (optionalBuf == null) {
            throw new Error("MultiValueHostCall, did not get the header name");
          } else {
            return fastly_http_req_header_values_get(
              handle,
              optionalBuf.buffer,
              optionalBuf.byteLength,
              buf.buffer,
              buf.byteLength,
              cursorStart,
              cursorEndPtr,
              nwrittenPtr
            );
          }
        }
      );

      let headerValues = new Array<string>();
      let hasNext = true;
      while (hasNext) {
        let headerValueBytes = headerValuesMultiValueHostCall.next();
        if (headerValueBytes == null) {
          hasNext = false;
        } else {
          let headerValue = String.UTF8.decode(headerValueBytes.buffer, true);
          headerValues.push(headerValue);
        }
      }

      // append each header value to our header name
      for (let j = 0; j < headerValues.length; j++) {
        let headerValue = headerValues[j];
        super.headers.append(headerName, headerValue);
      }
    }

    // Set that we now have out headers
    this._hasHeadersFromHandle = true;
  }

  _getBodyFromHandle(): void {
    // Create a readable stream of our body
    let bodyReaderOrNull = new ReadableBodyStream(
      this._requestBodyHandle
    ).getReader();
    if (bodyReaderOrNull == null) {
      throw new Error(
        "Could not get a ReadableBodyStreamReader from the request body handle."
      );
    }
    let bodyReader = changetype<ReadableBodyStreamReader>(bodyReaderOrNull);
    let bodyArrayBuffer = bodyReader.readAll();

    // Create our Body
    this._buffer = bodyArrayBuffer;
    this._hasBodyFromHandle = true;
  }

  get method(): string {
    if (!this._hasMethodFromHandle) {
      this._getMethodFromHandle();
    }

    return super.method;
  }

  get url(): string {
    if (!this._hasUrlFromHandle) {
      this._getUrlFromHandle();
    }

    return super.url;
  }

  get headers(): Headers {
    if (!this._hasHeadersFromHandle) {
      this._getHeadersFromHandle();
    }

    return super.headers;
  }

  get body(): ReadableBodyStream | null {
    // If we already waited for the response, we are done
    // and can't get a stream for the response
    this._consumeBody();

    let readableStream = new ReadableBodyStream(this._requestBodyHandle);
    return readableStream;
  }

  arrayBuffer(): ArrayBuffer | null {
    if (!this._hasBodyFromHandle) {
      this._getBodyFromHandle();
    }

    return super.arrayBuffer();
  }

  text(): string {
    if (!this._hasBodyFromHandle) {
      this._getBodyFromHandle();
    }

    return super.text();
  }

  // Don't need a send() as our top-level API
  // will do the correct conversion to an
  // upstream request or downstream response :)
}
