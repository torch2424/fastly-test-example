import {
  DictionaryHandle,
  fastly_dictionary_open,
  fastly_dictionary_get,
} from "./abi/abi";

import { FASTLY_STATUS } from "./abi/fastly-shared";

const DICTIONARY_MAX_LENGTH: i32 = 8000;

export class Dictionary {
  private _name: string;
  private _dictionaryHandle: DictionaryHandle;

  constructor(name: string) {
    this._name = name;
    this._dictionaryHandle = this._open(name);
  }

  private _open(name: string): DictionaryHandle {
    // Get our name as a UTF8 buffer
    let nameBuffer: ArrayBuffer = String.UTF8.encode(name);

    // Allocate a u32 for our host function
    let dictionaryHandlePointer = __alloc(4);
    let dictionaryHandleStatus = fastly_dictionary_open(
      nameBuffer,
      nameBuffer.byteLength,
      dictionaryHandlePointer
    );

    if (FASTLY_STATUS.isError(dictionaryHandleStatus)) {
      throw new Error("Could not open the dictionary with the name: " + name);
    }
    let dictionaryHandle = load<DictionaryHandle>(dictionaryHandlePointer);
    __free(dictionaryHandlePointer);

    return dictionaryHandle;
  }

  get(key: string): string | null {
    // We need to grab our value from the hostcall similar to
    // the util, getStringFromHandle, where the chunk keeps increasing. However,
    // Edge dictionaries has some special statuses on hostcall
    // so not going to use that util function here.

    // Get our name as a UTF8 buffer
    let keyBuffer: ArrayBuffer = String.UTF8.encode(key);

    // Get our value as a byte array
    let valueSize: i32 = DICTIONARY_MAX_LENGTH;
    let value: ArrayBuffer = new ArrayBuffer(valueSize);
    let nwrittenOut: usize = 0;
    let nwrittenOutPointer = __alloc(4);

    // If nwrittenout is 0, then we are done.
    let dictionaryGetStatus = fastly_dictionary_get(
      this._dictionaryHandle,
      keyBuffer,
      keyBuffer.byteLength,
      value,
      value.byteLength,
      nwrittenOutPointer
    );
    if (FASTLY_STATUS.isError(dictionaryGetStatus)) {
      throw new Error(
        "Could not read the key '" +
          key +
          "' from the dictionary with the name " +
          this._name +
          "'. Please ensure both the name and key are correct."
      );
    }

    // Get the nwrittenOut value
    nwrittenOut = load<u32>(nwrittenOutPointer);
    __free(nwrittenOutPointer);

    // Decode the string directly from the pointer and length
    let dictionaryValue = String.UTF8.decode(value, true);
    return dictionaryValue;
  }

  contains(key: string): boolean {
    // Get our name as a UTF8 buffer
    let keyBuffer: ArrayBuffer = String.UTF8.encode(key);

    // Create an empty value
    let value = new ArrayBuffer(0);

    // Create some empty pointers
    let nwrittenOutPointer = __alloc(4);

    let dictionaryGetStatus = fastly_dictionary_get(
      this._dictionaryHandle,
      keyBuffer,
      keyBuffer.byteLength,
      value,
      value.byteLength,
      nwrittenOutPointer
    );

    // Do some cleanup
    __free(nwrittenOutPointer);

    // If we get okay, or that the buffer is too long, than it does contain the value!
    if (
      FASTLY_STATUS.isOk(dictionaryGetStatus) ||
      dictionaryGetStatus == FASTLY_STATUS.BUFLEN
    ) {
      return true;
    }

    return false;
  }
}
