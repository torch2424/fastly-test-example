// Copyright 2020 Fastly, Inc.

import { Headers } from "@fastly/as-fetch";
import { BodyHandle, fastly_http_body_new } from "./fastly/abi/abi";
import { FASTLY_STATUS } from "./fastly/abi/fastly-shared";

import {
  WriteableBodyStream,
  WriteableBodyStreamWriter,
} from "./fastly/stream/writeable-body-stream";

// Function to check if a value is null in AS
export function isNull<T>(value: T): boolean {
  return changetype<usize>(value) == 0;
}

// Helper for getting the method and url from a downstream request.
// @param handle - Handle we will be reading from.
// @param readStringFunction - Callback that takes in a handle, a chunk which is
//   an array buffer that the hostcall should write the string to, and a pointer for
//   how many bytes were written. The callback returns a FASTLY_STATUS as an i32.
export function getStringFromHandle(
  handle: u32,
  readStringFunction: (
    handle: u32,
    chunk: ArrayBuffer,
    nwrittenPtr: usize
  ) => i32
): string {
  // Create a chunk to be filled
  let chunkSize: u32 = 0;
  let chunk: ArrayBuffer = new ArrayBuffer(chunkSize);

  let nwrittenOutPointer = __alloc(4);
  let nwrittenOut: u32 = 0;

  // Loop until the chunk is not completely filled.
  // Or in other words, we will write the string to the chunk
  // using the callback. If the amount of bytes written fills the entire
  // chunk, then we need to make a bigger chunk as we have a larger
  // string that can be contained in the chunk.
  while (nwrittenOut >= chunkSize) {
    chunkSize += 1024;
    chunk = new ArrayBuffer(chunkSize);

    let stringGetStatus = readStringFunction(handle, chunk, nwrittenOutPointer);
    if (FASTLY_STATUS.isError(stringGetStatus)) {
      throw new Error("Could not get the string value from the hostcall");
    }

    nwrittenOut = load<u32>(nwrittenOutPointer);
  }

  // Free our nwrittenOut
  __free(nwrittenOutPointer);

  // Decode the buffer
  let value = String.UTF8.decode(chunk, true);

  return value;
}

// Perhaps adding a method on a Request / Response class to do this for us :)
// https://github.com/fastly/ExecuteD/pull/275#discussion_r426943834
export function writeHeadersToHandle(
  headers: Headers,
  handle: u32,
  insertHeaderFunction: (
    handle: u32,
    headerNameBuffer: ArrayBuffer,
    headerValueBuffer: ArrayBuffer
  ) => void
): void {
  let headerKeys = headers.keys();
  for (let i = 0; i < headerKeys.length; i++) {
    let headerName = headerKeys[i];

    // Get the header name buffer
    let headerNameBuffer: ArrayBuffer = String.UTF8.encode(headerName);

    // Get the header values buffer
    let headerValueBuffer: ArrayBuffer = String.UTF8.encode(
      assert(headers.get(headerName))
    );

    insertHeaderFunction(handle, headerNameBuffer, headerValueBuffer);
  }
}

export function createBodyHandleAndGetWriteableBodyStream(
  buffer: ArrayBuffer | null
): WriteableBodyStream {
  // Allocate a u32 for our host function
  let bodyHandlePointer = __alloc(4);
  let bodyHandleStatus = fastly_http_body_new(bodyHandlePointer);
  if (FASTLY_STATUS.isError(bodyHandleStatus)) {
    throw new Error("Could not get the body handle from the host");
  }
  let bodyHandle = load<BodyHandle>(bodyHandlePointer);
  __free(bodyHandlePointer);

  // Create our writeableBodyStream from our bodyHandle
  let writeableBodyStream = new WriteableBodyStream(bodyHandle);

  // If we don't have a body, just pass back our handle
  if (isNull(buffer)) {
    return writeableBodyStream;
  }

  let body = changetype<ArrayBuffer>(buffer);

  // Write whatever we currently have in our body
  let streamWriterOrNull = writeableBodyStream.getWriter();
  if (streamWriterOrNull == null) {
    throw new Error("Writeable Body Stream is null");
  }
  let streamWriter = changetype<WriteableBodyStreamWriter>(streamWriterOrNull);
  streamWriter.write(body);
  streamWriter.releaseLock();

  return writeableBodyStream;
}
